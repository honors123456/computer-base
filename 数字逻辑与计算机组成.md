

## 一.二进制编码

### 1.基本结构

冯·诺伊曼结构

控制器：控制指令读写及执行，CU(Control Unit)

运算器：算术和逻辑运算的部件，ALU(Arithmetic and Logic Unit)

存储器:存储指令和数据

输入输出设备:

![](.\屏幕截图 2025-01-03 135445.png)

CPU:控制器，运算器，以及各类寄存器

内存：存储器

寄存器：用于各个部件临时存储数据的部件，如，存储器中的主存地址寄存器，主存数据寄存器；运算器中的通用寄存器组；控制器中的指令寄存器。

### 2.系统抽象层

![](.\屏幕截图 2025-01-03 140502.png)

操作系统是对计算机系统结构和计算机硬件的一种抽象。

指令集体系结构:软硬件之间交互的“桥梁”，ISA，例如，x86,arm,risc-v

微体系结构：ISA 是一个抽象层，而微体系结构则是对这些抽象定义的具体硬件实现。例如，

​						对于 x86 ISA，英特尔的 Core 系列和 AMD 的 Ryzen 系列都有不同的微体系结构（例如 

Intel,Skylake 或 AMD 的 Zen）。

​						对于 ARM ISA，英特尔、三星、高通等厂商的微体系结构实现可能有所不同。

### 3.二进制数的表示

![](.\屏幕截图 2025-01-03 141720.png)

#### （1）数值型数据

定点数：小数点位置固定的数

浮点数：小数点位置可浮动的数

定点数编码：（8位）

​	原码表示法：9		00001001

​							-9		10001001

​	补码表示法：9       00001001

​							-9     2^8+(-9)=11110111

​	反码表示法： 9	 00001001

​							-9	11110110

​	移码表示法：9      00001001

​							-9	偏移量+补码=2^7+11110111=10000000+11110111=01110111

浮点数表示：

​	浮点数由两个定点数表示：一个定点小数表示浮点数的尾数，一个定点整数表示浮点数的阶。

​	IEEE 754 单精度浮点数（32位）格式：

| 符号位 | 指数位 (E) | 尾数位 (M) |
|  1bit  |    8bit    |   23bit    |

​		例如：-13.625

13.625的二进制表示：13    1101   ； 0.625  101（0.625×2 =  1.250，取整数部分，0.25×2=0.5，取整数部分，0.5×2=1.0，去整数部分）

结果为：1101.101     使用科学计数法=1.101101×2^3

符号位：1

指数位：指数+指数偏移量=3+2^7-1=130=10000010

尾数位：1.101101的小数部分填充为23位，10110100000000000000000

最终表示为：1 10000010 10110100000000000000000

IEEE 754 双精度浮点数（64位）格式：

| 符号位 | 指数位 (E) | 尾数位 (M) |
|  1bit  |    11bit    |   52bit    |

#### （2）非数值型数据

对照ASCII码



## 二.数字逻辑基础

### 1.逻辑门和数字抽象

真值表

与门，或门，非门，与非门，或非门，异或门，同或门
$$
X·Y,X+Y,\overline{X},\overline{X·Y},\overline{X+Y},X \oplus Y,X \odot Y 
$$
![](.\屏幕截图 2025-01-06 170304.png)

![](.\屏幕截图 2025-01-06 170337.png)

![](.\屏幕截图 2025-01-06 170348.png)

### 2.基于布尔代数的公理系统

![](.\屏幕截图 2025-01-07 115308.png)



数字逻辑电路分为：组合逻辑电路和时序逻辑电路两类



## 三.组合逻辑电路

### 1.组合逻辑电路构成规则：

1.每个元件本身是逻辑电路

2.每个结点不能是两个元件的输出结点

3.不能是从一个输入端A经过若干个元件后到某个输出端B，然后再从输出端B连到输入端A
$$
\overline{(A ·B+B·\overline{C})·A}
$$
![](.\屏幕截图 2025-01-07 151306.png)



### 2.典型组合逻辑部件设计

译码器：一种多输入，多输出端电路。输入<输出

![](.\屏幕截图 2025-01-07 164856.png)
$$
I_{n} -> O_{2^{n}-1},     O_0=\overline{I_0}·\overline{I_1}·\overline{I_2}，O_1=\overline{I_0}·\overline{I_1}·I_2，O_2=\overline{I_0}·I_1·I_2，...... O_7=I_0·I_1·I_2，
$$
编码器：一种多输入，多输出端电路。输入>输出

![](.\屏幕截图 2025-01-07 170419.png)

多路选择器：从多个可能的输入中选择一个直接输出，最简单的多路选择器是二路选择器

多路分配器：将唯一的输入发送到多个输出端中的一个。

半加器：仅考虑两个加数的一位加法器

全加器（FA）：考虑两个加数和低位进位的一位加法器

![](.\屏幕截图 2025-01-07 172034.png)

$F=A \bigoplus B \bigoplus C$

$Cout=A \cdot B +(A + B) \cdot Cin$



## 四.时序逻辑电路

时序逻辑电路的结果输出由外部输入和内部状态共同决定。因此采用有限状态机来描述内部状态及其之间的联系。在电子电路中，记忆状态的元件有，SR锁存器，D触发器，KJ触发器等。

### 1.时序逻辑电路的基本结构

分为两类：Mealy型，Moore型

![](.\屏幕截图 2025-01-07 174540.png)

![](.\屏幕截图 2025-01-07 174549.png)

区别在于输出逻辑是否依赖当前输入。Mealy型输出逻辑依赖于当前输入和当前状态，而Moore型仅依赖于当前状态。

次态激励函数=f(输入信号，当前状态)

输出逻辑函数=f(输入信号，当前状态)

时序电路通常依赖于时钟信号来更新内部状态或触发逻辑操作。

### 2.锁存器和触发器

**锁存器**（Latch），基本由两个对称的与非门或者或非门组成。是一种**基本的存储单元**，它是一种能暂时保存 1 位二进制信息的电子电路，主要用在数字电路中。锁存器的核心作用是：**在输入信号发生变化后，能够根据控制信号的状态决定是否保持当前状态或更新为新的状态。**

#### SR锁存器（set-reset 锁存器）

![](.\屏幕截图 2025-01-08 115838.png)

**S = 0, R = 0（状态保持）**：无论当前Q是什么值，输出状态保持不变。

**S = 0, R = 1（复位状态）**：Q被复位为0，$\overline{Q}$为1。

**S = 1, R = 0（置位状态）**：Q被置位为1，$\overline{Q}$为0。

**S = 1, R = 1（禁止状态）**：这是一个无效状态，锁存器的逻辑会变得不可预测，因此禁止输入。

#### D锁存器

![](.\屏幕截图 2025-01-08 141937.png)

相当于在SR锁存器中加入了一些逻辑电路而成。

S=$\overline{D*C}$

R=$\overline{\overline{D}*C}$

可以看到S,R都与C有关，只要C输入0，S=R=1,无论D输入任何值。可以认为D（数据输入）和C（控制信号）。

D锁存器的作用是**消除SR锁存器的无效状态（S=1, R=1）**，使其工作变得简单稳定。

#### D触发器

D触发器的主要功能是**将输入数据 D 锁存到输出 Q**，并在时钟信号（CLK）的控制下更新其状态。它的行为可以简单地理解为：**输入信号 D 在时钟触发时复制到输出 Q**。

##### **工作原理**

- 当时钟信号上升沿或下降沿（根据设计）到来时，触发器将 D的值传递到 Q。
- 在非触发的时间内，输出 Q 保持不变

![](.\屏幕截图 2025-01-08 151657.png)

时钟信号Clk为高电平时，左边锁存器开，右边锁存器关，输入端D信号被所存在左边的D锁存器中的Q中；Clk从高电平转为低电平时，左边锁存器关，右边锁存器开，左边锁存器的Q的信号被所存在右边的D锁存器中的Q中。

![](.\屏幕截图 2025-01-08 152155.png)

#### T触发器

T触发器的主要功能是**根据输入信号 T的状态，在时钟触发时对输出 Q进行翻转（Toggle，即从0变1或从1变0）或保持原值**。因此，T触发器也被称为“翻转触发器”。

##### 工作原理

如果输入 T=0，则 Q保持不变。

如果输入 T=1，则 Q 翻转。

![](.\屏幕截图 2025-01-08 153236.png)
$$
D_{n+1}=T_{n}⊕Q_{n}
$$
T触发器可以看作是D触发器和其他电路的实现。下一D触发器的信号输入，决定于当前T和当前输出Q的异或.

通过这种方式实现的 T触发器常用于：

1. **计数器**（如二进制计数器）。
2. **频率分频器**（当 T=1 时，每次翻转，相当于将时钟信号的频率减半）。



#### 计数器

1. 串行计数器

   - 异步串行加法计数器

     ![](.\屏幕截图 2025-01-08 160243.png)

     Q状态由1->0,会产生进位信号，该进位信号会传递给下一个T输入。

初始状态$T$=$Q_0$=$Q_1$=$Q_2$=$Q_3$=$D_0$=0，$Q_3 Q_2 Q_1 Q_0$=0000，

第一个Clk信号

$T_0$=1，$Q_0$翻转为1，

$T_1$=0, $Q_1$=0,

$T_2$=0, $Q_2$=0,

$T_3$=0, $Q_3$=0,

状态为$Q_3 Q_2 Q_1 Q_0$=0001;



第二个Clk信号

$T_0$=1，$Q_0$翻转为0，产生进位信号

$T_1$=1, $Q_1$翻转为1,

$T_2$=0, $Q_2$=0,

$T_3$=0, $Q_3$=0,

状态为$Q_3 Q_2 Q_1 Q_0$=0010;



第三个Clk信号

$T_0$=1，$Q_0$翻转为1，

$T_1$=0, $Q_1$=1,

$T_2$=0, $Q_2$=0,

$T_3$=0, $Q_3$=0,

状态为$Q_3 Q_2 Q_1 Q_0$=0011;



第四个Clk信号

$T_0$=1，$Q_0$翻转为0，产生进位信号

$T_1$=1, $Q_1$翻转为0,产生进位信号

$T_2$=1, $Q_2$翻转为1,

$T_3$=0, $Q_3$=0,

状态为$Q_3 Q_2 Q_1 Q_0$=0100;

## 五.FPGA设计（略）



## 六.运算方法和运算部件

### 1.基本部件

ALU 算数逻辑部件

##### 1.串行进位加法器

​	n个全加器串联，就是串行进位加法器

![](D:\Code\数字逻辑与计算机组成\屏幕截图 2025-01-09 092314.png)

##### 2.并行进位加法器

​	由上文可知

​		$Cout_n=A_n \cdot B_n + (A_n + B_n) \cdot Cout_{n-1} $

​		$Cout_{n-1}=A_{n-1} \cdot B_{n-1} + (A_{n-1} + B_{n-1}) \cdot Cout_{n-2} $

​		.............

​	可以看出只和$A_n+B_n$与$A_n \cdot B_{n}$有关

​	于是

​	
$$
	P_n=X_n + Y_n
$$

$$
G_n=X_n \cdot Y_n
$$

$$
Cout_n=P_n + G_n \cdot Cout_{n-1}
$$

$P_n$为进位传递函数，若$X_n$和$Y_n$中有一个为1时，而且$Cout_{n-1}$为1时，则一定会传递到高位。

$G_n$为进位生成函数，若$X_n$和$Y_n$均为1时，不管有无低位进位输入，本位一定向高位进位。

由此产生先行进位部件，构成全先行进位加法器

![](D:\Code\数字逻辑与计算机组成\屏幕截图 2025-01-09 115845.png)

### 2.定点数运算

#### 	1.补码加减法(四位)

​		-7补码加-6补码

​			-7 补码   原码取反加1 0111    =》 1000+1  =》1001

​			-6补码   0110  =》1001+1 =》1010

​			1001 + 1010 = 0011

#### 	2.原码乘除法

#### 	3.补码乘除法

#### 	4.浮点数加减

#### 	5.浮点数乘除



## 七.指令系统

### 1.操作数

​	操作数，指令处理的对象。分为以下几类：

- 无符号整数。指针和主（虚）存地址
- 有符号数值数据。浮点数和有符号整数
- 位，位串，字符，字符串
- 布尔数据

### 2.寻址方式

- 立即寻址。在指令中直接给出操作数本身。
- 直接寻址。在指令中给出操作数的有效地址。
- 间接寻址。一个存储单元中存储操作数的有效地址，在指令中给出存储单元的有效地址。
- 寄存器寻址。在指令中给出操作数所在的寄存器编号。
- 寄存器间接寻址。操作数的有效地址存放在某个寄存器中，在指令中给出寄存器编号。
- 变址寻址。指令中给出操作数的有效地址（基地址），加上变址寄存器中存放的偏移量。
- 相对寻址。指令中包含一个常量偏移量，然后加上PC(程序计数器，即寄存器)中存放的有效地址。
- 基址寻址。基址寄存器中存放操作数的有效地址（基地址），在指令中给出偏移量

### 3.指令系统

- 算数逻辑指令
  - ADD ,SUB, CMP, MUL ,DIV ,AND ,OR, NOT, NEG, XOR, INC, DEC, 
- 移位指令
  - 算数移位，逻辑移位，循环移位，半字交换
- 数据传送指令
  - 寄存器之间的传送（MOV），内存单元传送到CPU寄存器（LOAD），CPU寄存器传送到内存单元（STORE）
- 串指令
  - 串传送，串比较，检索，传送转换。
- 顺序控制指令
  - 控制程序执行顺序。有条件转移（BRANCH）,无条件转移（JMP）,调用（CALL）,返回（RET）
- 系统控制指令
  - 停机，开中断，关中断，系统模式切换，以及一些内核指令
- 输入输出指令
  - 用于CPU和外部设备数据交换

### 4.标志信息

​	条件转移指令，根据生成的标志信息进行转移。标志信息也称为条件码，状态位。由条件码寄存器来存放。

​	零标志ZF,溢出标志OF,符号标志SF,进位标志CF

![](D:\Code\数字逻辑与计算机组成\屏幕截图 2025-01-10 133708.png)

### 5.指令系统风格

- 以操作数位置来分
  - 累加器型
  - 栈型，例如java虚拟机
  - 通用寄存器
  - Load/Store型
- 指令格式复杂度
  - CISC
  - RISC

### 6.异常和中断处理

- 异常

  异常是处理器在执行指令时发生在CPU内部的事件

  如，除0，溢出，断点设置，单步跟踪，访问超时，非法操作码，

- 中断

  通常是外设向CPU发送的中断请求，进行特定的中断处理

### 7.RISC-V架构

#### 	1.基础整数指令RV32I

​			RTL语言约定（寄存器传送级语言约定）：

​					R[r]表示通用寄存器r的内容

​					M[addr]表示存储单元addr的内容

​					M[R[r]] 表示寄存器r指向的存储单元的内容

​					PC表示PC（程序计数器，即控制程序执行流程的核心寄存器）的内容

​					M[PC]，表示PC指向的存储单元的内容

​					SEXT[imm]表示对imm进行符号拓展（imm立即数，直接嵌入在指令中的常量）

​						如果 `imm` 的最高位是 `1`，扩展时补 `1`；如果是 `0`，扩展时补 `0`

​						例子: 假设 `imm` 是 8 位的二进制数 `1111 0101`，进行符号扩展到 16 位后：

​									SEXT[imm] = 1111 1111 1111 0101

​					ZEXT[imm]表示对imm进行零扩展

​						不论 `imm` 的最高位是什么，扩展时都补 `0`

​						例子: 假设 `imm` 是 8 位的二进制数 `1111 0101`，进行零扩展到 16 位后：

​									ZEXT[imm] = 0000 0000 1111 0101

​					传送方向  <------	数据从右侧传送到左侧。

![](D:\Code\数字逻辑与计算机组成\屏幕截图 2025-01-10 153101.png)

#### 	2.控制转移类指令

#### 	3.存储器访问类指令

#### 	4.系统控制类指令



## 八.中央处理器

### 1.CPU基本功能

​	程序由指令序列和数据组成。指令按顺序存放在内存连续单元中，将要执行的指令的地址由PC（程序计数器）给出。CPU取出并执行一条指令的时间称为指令周期。

CPU执行指令的过程：

1. 取指令。从PC指向的内存单元中取出指令送到指令寄存器（IR）
2. 对IR中的指令操作码进行译码，并计算下条指令地址。
3. 计算源操作数地址并取源操作数。如果源操作数是存储器数据，需要一次或多次访存。如果是寄存器数据，直接取数
4. 对操作数进行运算
5. 计算目的操作数地址并存结果
