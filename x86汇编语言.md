以下内容全基于8086CPU

## 一.寄存器

#### 1.通用寄存器

8086CPU所有寄存器都是16位，可以存放2个字节。AX,BX,CX,DX，是通用寄存器。

AX -------->AH(高位)   AL(低位)   

BX -------->BH(高位)   BL(低位) 

CX -------->CH(高位)   CL(低位) 

DX -------->DH(高位)   DL(低位) 

![](.\屏幕截图 2025-01-16 170424.png)

字  word 两个字节

字节 byte 1个字节



#### 2.简单汇编指令

![](.\屏幕截图 2025-01-16 170642.png)

#### 3.段地址

物理地址：所有内存单元构成的存储空间是一个一维的线性空间，每个内存单元都有唯一的地址，称为物理地址。

段地址：内存没有分段，但是CPU会对内存进行分段，例如，地址10000H~~100FFH的内存单元组成一个段，该

​				段的基础地址为10000H,段地址为 1000H,大小为100H。段地址 = 基础地址 / 16。

段地址分为3类，数据段，栈段，代码段

**物理地址**=**段地址** x 16 + **偏移地址**       （段地址 和 偏移地址 分别存储在对应的寄存器中）

![](.\屏幕截图 2025-01-16 174349.png)



#### 3.代码段寄存器

8086CPU有4个段寄存器。CS,DS,SS,ES。

CS		Code Segment 代码段寄存器

DS		Data Segment 数据段寄存器

SS		Stack Segment 栈段寄存器

ES		Extra Segment 额外段寄存器



CS和IP是8086CPU中最关键的寄存器，指示了指令的物理地址，CS是代码段寄存器，IP是指令指针寄存器。

![](.\屏幕截图 2025-01-16 180006.png)

在内存中有许多内存单元，但是CPU只认CS:IP指向的内存单元中的内容为指令。



#### 4.修改CS，IP指令

8086CPU不能使用mov来设置CS,IP的值。

jmp 2AE3:3           设置后，CS=2AE3H，IP=0003H，物理地址 2AE33H

jmp ax				   假设ax=0005H，设置后 CS=2AE3H，IP=0005H，物理地址 2AE35H，仅改变IP的内容



#### 5.数据段寄存器

DS	Data Segment 存储数据的段地址

mov bx,1000H

mov ds,bx

mov al,[0]

8086CPU不能直接mov ds,1000H，所以必须使用ax存储段地址

[0]，表示内存单元的偏移地址是0，默认段地址是ds，al是ax的低地址单元



#### 6.栈段寄存器

栈，先进后出。

![](D:\Code\computer-base\屏幕截图 2025-01-17 102200.png)



SS:SP指向栈顶元素

SP=SP-2



## 二.汇编程序入门

#### 1.基本过程

源程序-----(编译)------>.obj-------(链接)------->.exe



#### 2.源程序

![](D:\Code\computer-base\屏幕截图 2025-01-17 104259.png)



assume 假设某个寄存器和某个段相关联，cs:codesg，代码段寄存器和codesg段关联

codesg segment  定义一个段，段名称“codesg”

codesg ends		 名称“codesg"的段到此为止

end 汇编程序的结束标记



mov ax,4c00H

int 21H				程序返回

![](D:\Code\computer-base\屏幕截图 2025-01-17 111948.png)

![](D:\Code\computer-base\屏幕截图 2025-01-17 112037.png)



#### 3.Loop指令



现在约定：

()，表示寄存器或者内存单元中的内容

idata，表示常量

##### 1.[bx]

与[0]一样，(ds)*16+(bx)，只不过偏移地址存放在bx寄存器中

mov ax,[bx]         (ax)=(ds) * 16 + (bx)

mov [bx],ax		 (ds) * 16 + (bx)=(ax)



##### 2.Loop

计算2^20

assume cs:code

code segment

​	mov ax,2

​	mov cx,19

s: add ax,ax

​	loop s

​	mov ax,4c00h

​	int 21h

code ends

end

循环次数一般放在 cx 寄存器中

标号 s,标识了一个地址，这个地址有一条指令:add ax,ax

执行loop时，（cx）=（cx）- 1



**debug 中 命令行输入汇编指令 mov al,[0]    [0] 代表（ds）*16 +(0)处的内存单元**

**MASM 中 源程序中写入汇编指令 mov al,[0] ，[0]会被直接翻译成0，立即数，即mov al,0**，**所以要显式表示 mov al,ds:[0]**



#### 4.段前缀

上面的ds:，cs:，ss:，es:显式的指明内存单元的段地址



#### 5.安全空间

在纯DOS方式（实模式）下，可以直接用汇编去操作真实的硬件。但是，在保护模式（普通）下，不可以，会容易改变某些系统的内存数据，造成系统错误。所以，需要找安全空间内存，去进行汇编编码。一般PC，0:200~0:2ff的256字节空间是安全的。



#### 6.包含多个段的程序

##### 	1.代码段中使用数据

```asm
assume cs:code
code segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	
	start:	mov bx,0
			mov ax,0
			
			mov cx,8
    	s:	add ax,cs:[bx]
    		add bx,2
    		loop s
    		
    		mov ax,4c00h
    		int 21h

code ends
end start
```

dw 是defined word，因为dw定义的数据处于代码段的最开始，所以偏移量处于0。数据存放在CS:0~~CS:F中。

start 表示程序指令的入口，表明偏移量在dw定义的数据的末尾，所以代码段(CS:IP)=(cs)*16+10h，CPU只认CS:IP指向的内存单元中的内容为指令。

end start 描述程序的结束。



##### 2.代码段中使用栈

```asm
assume cs:code
code segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	
start:	mov ax,cs
		mov ss,ax
		mov sp,30h	//定义栈顶(SS:SP) = (CS)*16+30H
		
		mov bx,0
		mov cx,8
		
	s:	push cs:[bx]	
		add bx,2
        loop s		
        //压栈，0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0变为			push时，sp=sp-2	  0,0,0,0,0,0,0,0,0987h,0cbah,0fedh,0defh,0abch,0789h,0456h,0123h,(SS:SP) = (CS)*16+20H
		
		mov bx,0
		mov cx,8
		
	s0:	pop cs:[bx]	
		add	bx,2
		loop s0
		//出栈
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0变为			push时，sp=sp+2	
	0,0,0,0,0,0,0,0,0987h,0cbah,0fedh,0defh,0abch,0789h,0456h,0123h,(SS:SP) = (CS)*16+30H
		0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h变为
		0987h,0cbah,0fedh,0defh,0abch,0789h,0456h,0123h
		
		mov ax,4c00h
		int 21h
		
code ends
end start
```



##### 3.数据，代码，栈放入不同的段

```asm
assume cs:code,ds:data,ss:stack

data segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends

code segment
start:	mov ax,stack
		mov	ss,ax
		mov	sp,20h
		mov	ax,data
		mov	ds,ax
		
		mov	bx,0
		mov	cx,8
	s:	push [bx]
		add	bx,2
		loop s
		
		mov	bx,0
		mov	cx,8
	s0:	pop	[bx]
		add	bx,2
		loop s0
		
		mov ax,4c00h
		int 21h
		
code ends
end start
```



## 三.内存地址定位

#### 1. and 和 or 指令

##### （1）and指令：逻辑与指令

​		mov	al,01100011B

​		and	al,00111011B

​		执行后：al = 00100011B

##### (2) OR指令：逻辑或指令

​		mov	al,01100011B

​		or		al,00111011B

​		执行后：al = 01111011B



#### 2.ASCII码

```asm
assume cs:code,ds:data

data segment
db	'unIX'
db	'foRK'
data ends

code segment
start:	mov	al,'a'
		mov	bl,'b'
		
		mov	ax,4c00h
		int 21h
		
code ends
end start
```



#### 3.[bx+idata]

[bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata



#### 4.SI和DI寄存器

si，di是8086CPU中和bx功能相近的寄存器，且不能够分成两个8位寄存器来使用。

用si和di实现将字符串‘welcome to masm!’复制到它后面的数据区里面.

```asm
assume cs:code,ds:data		//代码段与code段关联，数据段与data段关联

data segment
	db 'welcome to masm!'
	db '................'
data ends

code segment
	start:	mov	ax,data
			mov	ds,ax
			mov	si,0
			mov	di,16
			
			mov	cx,8
		s:	mov	ax,[si]
			mov	[di],ax
			add	si,2
			add	di,2
			loop s
			
			mov	ax,4c00h
			int	21h
code ends
end start
```

所以，内存单元又可以表示为[bx+si]，[bx+di]，[bx+si+idata]，[bx+di+idata]



#### 5.不同寻址方式的应用

```asm
assume cs:code,ds:data

data segment
	db	'ibm             '
	db	'dec             '
	db	'dos             '
	db	'vax             '
	dw	0
data ends

code segment
	start:	mov	ax,data
			mov	ds,ax
			mov	bx,0
			
			mov cx,4
		s0:	mov ds:[40h],cx
			mov	si,0
			mov cx,3
		s:	mov al,[bx+si]
			and al,11011111b		//小写转大写，大小写区别在于二进制第五位不同
			mov [bx+si],al
			inc si
			
			loop s					//顺序执行到该步，跳转到s，继续顺序执行
			
			add bx,16
			mov cx,ds:[40h]
			loop s0					//顺序执行到该步，跳转到s0，继续顺序执行
			
			mov ax,4c00h
			int 21h
code ends
end start
```



## 四.数据处理的两个基本问题

